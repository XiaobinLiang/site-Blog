<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,熊猫小A,Galileo,blog" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="无文字 | 三无计划 &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="无文字 | 三无计划 &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/prism-561767ec37.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/993aa3dcb70943b3e506b13b3d502541.json"
        }

    </script>
    
<title>无文字 | 三无计划</title>
<meta name="author" content="熊猫小A" />
<meta name="description" content="只坚持一种正义。我的正义。" />
<meta property="og:title" content="无文字 | 三无计划" />
<meta property="og:description" content="只坚持一种正义。我的正义。" />
<meta property="og:site_name" content="无文字 | 三无计划" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/page/4/" />
<meta property="og:image" content="无文字 | 三无计划" />
<meta name="twitter:title" content="无文字 | 三无计划" />
<meta name="twitter:description" content="只坚持一种正义。我的正义。" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/android-chrome-512x512.png" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="dns-prefetch" href="//blog.imalan.cn" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/brand_font/embed.css" />
<style>.brand{font-family:FZCuJinLFW,serif;font-weight: normal!important;}</style>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/apple-touch-icon.png?v=PY43YeeEKx">
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/favicon-32x32.png?v=yyLyaqbyRG">
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/favicon-16x16.png?v=yyLyaqbyRG">
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/safari-pinned-tab.svg?v=yyLyaqbyRG" color="#505050">
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/favicon.ico?v=yyLyaqbyRG">
<meta name="application-name" content="三無計劃">
<meta name="apple-mobile-web-app-title" content="三無計劃">
<meta name="msapplication-TileColor" content="#000000">
<meta name="theme-color" content="#000000">
<meta name="baidu-site-verification" content="9BEwwo6Ibg" />

</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase"><a class="no-link" href="/" target="_self">无文字 | 三无计划</a></h1>
            <p>只坚持一种正义。我的正义。</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase " href="/" target="_self">首页</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">归档</a></li><li><a class="no-link text-uppercase " href="/links/" target="_self">友链</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">关于</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">搜索</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/277/" target="_self">Sticky：CSS 粘性布局</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/277/" target="_self">
                <time class="text-uppercase">
                    March 03 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>最近发现了一个不错的 CSS 属性：<code>position:sticky</code>，这个尚处于实验阶段的属性可以很好的解决网页中边栏随滚动固定的问题。</p>
<p>先看一个 Demo，在上下滚动过程中注意右侧红色块的行为：</p>
<iframe height="450" style="width: 100%;" scrolling="no" title="position: sticky Demo" src="//codepen.io/AlanDecode/embed/gErQqq/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/AlanDecode/pen/gErQqq/'>position: sticky Demo</a> by AlanDecode
  (<a href='https://codepen.io/AlanDecode'>@AlanDecode</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe><p>这就是 <code>position: sticky</code> 的作用。以下部分摘选自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN Position</a>：</p>
<blockquote><p>盒位置根据正常流计算（这称为正常流动中的位置），然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table 时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code> 对 <code>table</code> 元素的效果与 <code>position: relative</code>相同。</p>
</blockquote>
<p>因此，应用这个属性并不会破坏网页原有布局，super cool。</p>
<p>应用时，除了指定 <code>position: sticky</code> 外还必须指定 <code>top</code>、<code>bottom</code>、<code>right</code>、<code>left</code> 中至少一个作为阈值，当元素距离 viewport 边缘的距离达到这个阈值时就会触发黏性布局。</p>
<p>兼容性：</p>
<p><figure class="pswp-item" style="flex: 184.03954802259886" data-width="1303" data-height="354"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/472fe68f97b44c7cd393bc0a3473373b.png" alt="兼容性，2019-03-03" /><figcaption>兼容性，2019-03-03</figcaption></figure></p>
<p>emmm，如果不是生产环境，还是可以玩玩的。另外有开源库可以稍稍提升一下这个属性的兼容性：<a href="https://github.com/filamentgroup/fixed-sticky">filamentgroup/fixed-sticky</a>，但是这个项目已经 Archive 了。</p>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/277/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/273/" target="_self">观《网络谜踪》有感</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/273/" target="_self">
                <time class="text-uppercase">
                    February 28 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>我给这部影片打了 5 星。这绝对是值得一看的作品，若你自认为自己对科技、网络安全、隐私了解不少，那你更应该看看这部电影。电影的剧情当然很精彩，但是这是一部剧情片，我不好剧透。况且最触动我的并不是剧情。</p>
<p>对科技有一定敏感度的人一定会对电影里出现的各种操作系统印象深刻。从 Widows XP，到 iOS，到 OS X，到 Ubuntu，电影里在不同场合不同时间出现各种界面 —— 男主正是在这些不同的设备、操作系统中搜集信息，破解谜团。特别让我感到震动的是：电影对这些界面的模拟几乎到了吹毛求疵的地步，或者说「模拟」这个词都不恰当，因为据说某些场景剧组是直接在实机上拍摄的。这让我得到了非常强的沉浸感，因为我会把自己带入成男主，思考如果是我该怎么处理。这是一个打动我的点。</p>
<p><figure class="pswp-item" style="flex: 89.08765652951699" data-width="1992" data-height="1118"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/6e983854b2fd6d45b1e2d9ce34ae5e53.png" alt="电影中的 OS X 界面" /><figcaption>电影中的 OS X 界面</figcaption></figure></p>
<hr>
<p>另一个点在于数字世界的隐私问题。世界上鼎鼎有名的三家公司：Facebook、Google、Apple 每天都把隐私放在嘴边，但实际上第一家的隐私丑闻从来就没有停过；后两者名声稍好，但是电影里我们可以看到男主如何巧妙地利用安全邮箱重置密码来破解账户。要知道，安全邮箱或者安全电话号码是世界上最广泛采用的验证方式。实际上：只要攻击者对你的信息有足够的掌握，没有密码是不能破解的，没有系统是不能攻入的。</p>
<p><figure class="pswp-item" style="flex: 89.36936936936937" data-width="1984" data-height="1110"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/f82d2314bf6876e9b734ee16228540b8.png" alt="使用安全邮箱重置密码" /><figcaption>使用安全邮箱重置密码</figcaption></figure></p>
<p>这或许让一部份笃信「数字世界无隐私」的人信心大增，毕竟电影给出了一个活生生的例子。这些人觉得，若要有隐私，那就别上网吧。</p>
<p>我不愿接受这种略显犬儒的思想。但说实话，我有什么解决方案吗？我没有。</p>
<hr>
<p>最后一点是：网络究竟能在多大程度上还原作为数字世界原住民的我们。</p>
<p>「数字世界原住民」指的是没有经过刻意的学习就会上网的人群，比如我这一代人。我们近乎无私地把自己的身份、偏好等等信息奉献给了互联网。那么利用互联网到底能在多大程度上拼凑出我这个活人呢？</p>
<p>No，使用互联网不能拼凑出现实世界中的我。But yes，使用互联网能拼凑出网络世界中的我。现实世界中的我、网络世界中的我都是我，甚至很难说到底哪个才最接近我的本质。</p>
<p>我活在网络上时，身上少了世俗礼仪的负担，也少了道德约束，因此看上去更容易暴露出面具下的本质，这时候网络就成了一个照妖镜。不如试着以局外人的视角看看自己的博客、微博、Twitter，试着构想一下这些账号的主人，与你自认的自己是否有偏差？</p>
<p>这么想来真不可思议：几十亿网民，活生生地因为上网而人格分裂了。</p>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/273/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/267/" target="_self">Setup 变更：MacBook Pro！</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/267/" target="_self">
                <time class="text-uppercase">
                    February 24 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>从去年下半年开始我一直是同时在使用两个笔记本：联想 R720 与华为 MagicBook，一个用于实验室项目，一个用于个人项目以及日常使用。如今有了点小变化：MagicBook 淘汰，MacBook Pro 加入！</p>
<p>联想 R720 是本科毕设的时候买的，当时的项目有用到 CUDA，但之前的笔记本并没有独显，因此就选了个相对性能强劲的笔记本。512G 固态 + 1TB 机械、16G 内存、i7 7700HQ 的配置足够我使用好几年了。因此它现在在实验室好好地待着，处理所有的脏活累活。</p>
<p>但是 R720 实在太大太重，而且<strong>太丑了</strong>。于是我购入了华为 MagicBook 锐龙版，使用了半年。说实话我对这个本子大体而言还是相当满意的，它轻薄、小巧、续航强劲，而且有一块超出我期望的触控板，半年里用这个笔记本写作业写博客写代码都毫不费劲。</p>
<p>不过这个本子于我而言还是不那么适合。锐龙处理器虽然在性价比上确实没的说，但是在某些吃性能的场景下就比较吃力了，另外似乎这个处理器有一些兼容性问题，成了日常使用的不稳定因素。屏幕是另一个问题，MagicBook 的屏幕偏色严重，我在社交网络上搜索了一圈，发现这不是个例。另外，2018 年冬天 MagicBook 曝出了严重的品控问题：<a href="https://cn.club.vmall.com/thread-16716943-1-2.html">转轴鼓包</a>，我身边就有朋友中招。因此我动了换掉它的心思。</p>
<p>话说我对 MacBook 神往已久了。大一时用过，但是由于专业的原因不得已换掉了（当时尚没有能力去折腾调教），现在我折腾技术逐渐成熟，加上有 R720 帮我做脏活，工作需求上不再有问题。我对 macOS 这样类 UNIX 的系统也十分感兴趣。过多的思考只会导致优柔寡断，于是下手了一台 MacBook Pro 2015。</p>
<p><figure class="pswp-item" style="flex: 67.62422360248448" data-width="1742" data-height="1288"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/8675e3e6db42863f61ab4130b78f128e.png" alt="macOS" /><figcaption>macOS</figcaption></figure></p>
<p>之所以是 2015，是因为这是我觉得最综合的一款 MacBook Pro。没有 Touch Bar，但是有完整的功能区按键；没有 Type C，但是有齐全的 Type A USB 接口与  历史上的神级设计：MagSafe（我认为苹果把这个砍掉是极其愚蠢的决定）；触控板面积比 2016 要小，但是却有手感好得多的键盘！在这台机器上我确定能得到完整的 Mac 体验。</p>
<p>到手之后就一个字：香！</p>
<p>Mac 这块屏幕真的太舒服了，非常细腻，色彩准确，导致许多东西颜值直接攀升。另外得益于 macOS 的渲染机制，在如此高分辨率的屏幕上也不会出现 Windows 上文字与图标小得瞎眼的问题。</p>
<p>苹果的硬件生态是一大杀手锏。Mac 上直接通过 iPhone 接打电话、收短信；通过 AirDrop 与 iPhone 互传文件；这些比较细微（看起来也不常用）的功能，一旦用上了就会直呼真香。另外 AirPods 与 Mac 的配合也很舒服：在 Windows 上 AirPods 必须以传统的蓝牙耳机的方式配对，多有不便；在 Mac 上则是无缝配对，与 iPhone 无缝切换。顿时有了这一切都在我控制中的感觉。</p>
<p>软件生态是另一大杀手锏。我有段时间对折腾 App 很着迷，因此我知道 Mac 上有很多设计精良的  App，这次也如愿以偿用地上了它们。我购入了 <a href="https://setapp.com/">Setapp</a>，这个订阅服务还是相对比较划算的：学生价 $5 一月，包含的 App 还算质量上乘、内容全面。办公软件方面直接用 Office 365 即可。</p>
<p><figure class="pswp-item" style="flex: 80.0" data-width="2880" data-height="1800"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/aec6d9d35e8bc2eb54ab2d5113c6755c.png" alt="我在使用的部分 App" /><figcaption>我在使用的部分 App</figcaption></figure></p>
<p>另外 macOS 是类 UNIX 的系统，许多东西会方便得多，也快得多。PHP、Apache、Python、Ruby 等等都是自带的，加上 Mac 上强大的包管理工具 <a href="https://brew.sh/">Homebrew</a>，软件安装、管理都很方便。代码编辑器我仍然使用 VS ​Code，配合 <a href="https://kapeli.com/dash">Dash</a> 写代码也很舒服。终端环境我还是在使用 bash，但是有点想换到 zsh 试试。写文章还是用 Typora（Ulysses 的 Markdown 语法不全面)。</p>
<p>总而言之，对这次 Setup 转换很满意，everything is cool.</p>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/267/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/261/" target="_self">Typecho 搜索增强：ExSearch</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/261/" target="_self">
                <time class="text-uppercase">
                    February 19 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>Typecho 中没有单独的搜索页，绝大多数主题的所谓「搜索页」只是为搜索框单独写了一个样式，具体的搜索还是靠页面跳转。我对 Typecho 的搜索从来没有满意过，因此这次我想办法将其增强。</p>
<hr>
<blockquote><p>🔍 为 Typecho 带来实时搜索体验</p>
</blockquote>
<p>项目地址：<a href="https://github.com/AlanDecode/Typecho-Plugin-ExSearch">ExSearch</a>，使用方法见：<a href="https://github.com/AlanDecode/Typecho-Plugin-ExSearch/blob/master/README.md">README.md</a>。</p>
<p>对于 <a href="https://blog.imalan.cn/archives/247/">VOID</a> 主题，只需要下载启用插件，并建立缓存即可,主题已针对插件做了适配。</p>
<p>我需要为 Typecho 添加搜索实时响应、高亮与预览功能。<a href="https://qqdie.com/">泽泽</a>的搜索插件通过 hack Typecho 的内部方法实现了高亮与过滤功能，但是仍然不能实现实时响应。其实也能理解，如果跟随输入实时响应的话，数据库的压力大大增加，而且网络压力也大大增加。必须另辟蹊径。</p>
<p>我在<a href="https://blog.imalan.cn/archives/108/">为什么每个人都应该有自己的 Wiki</a>中提到自己启用了 <a href="https://github.com/zthxxx/hexo-theme-Wikitten">Wikitten</a> 这个 Hexo 主题作为自己的 Wiki 站点主题。其中很重要的一个原因就是它舒服到无以复加的搜索体验。Hexo 这样无后端的博客为我提供了新的思路：将内容静态化，使搜索在前端进行。这样不仅降低了数据库压力，节省了网络请求数，同时也不用与 Typecho 的内部方法作斗争。唯一的缺点是对内容过多的站点来说需要传输一定数量的内容到前端，但这通过缓存静态化与前端长缓存也能缓解。</p>
<p>最终的结果便是这个插件。</p>
<p><strong>如果这个项目对你有所帮助，请考虑向我我捐助 ↓↓↓</strong></p>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/261/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/259/" target="_self">Semantic Web：结构化数据</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/259/" target="_self">
                <time class="text-uppercase">
                    February 01 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>文章标题是几个故弄玄虚的词，但本文要聊的是更具体与实用的东西：从某些愿景出发，谈诸如 Microdata、Microformat、JSON-LD 等概念与其实践。</p>
<!--more-->


<h2>0X01: Semantic Web</h2>
<p><ruby>语义网<rp>(</rp><rt>Semantic Web</rt><rp>)</rp></ruby>是由 Tim Berners-Lee 于 1998 年提出的概念，它的核心是给万维网上的文档（例如 HTML）添加可以被机器理解的语义作为文档的<ruby>元数据<rp>(</rp><rt>metadata</rt><rp>)</rp></ruby>，使整个互联网成为一个通用的信息交换媒介<sup id="fn_ref_1"><a href="#fn_1">1</a></sup>。</p>
<p>说得更简单些，语义网的宗旨是帮助计算机理解网络上各种资源到底是什么，以此来使信息的集合、分发、分析效率更高，并且有的放矢。</p>
<p>语义网的实现途径有很多，例如 HTML 中的各种语义化标签就是一例。我们常常推荐使用诸如 <code>&lt;nav&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;aside&gt;</code> 等标签代替单纯的 <code>&lt;div&gt;</code>，背后的目的之一就是使 HTML 文档具有更好的语义：对机器而言，更容易理解页面上具体是什么。<a href="https://www.w3schools.com/html/html_accessibility.asp">HTML Accessibility</a>  就相当依赖这些语义数据，读屏软件<sup id="fn_ref_2"><a href="#fn_2">2</a></sup>可以很清楚地知道 <code>&lt;nav&gt;</code> 标签中的链接代表着页面导航，<code>&lt;figure&gt;</code> 标签中的内容代表着文章配图与图题，使用 <code>&lt;div&gt;</code> 与 <code>&lt;img&gt;</code> 标签在视觉展示效果上也许能达到相同的效果，但是它背后蕴含的信息量却是截然不同的。不过 Accessibility 是一个大议题，不是本文重点。</p>
<p>语义网通过使用标准、标记语言以及相关的工具作为技术实现手段，本文要聊的就是其中一种：<ruby>结构化数据<rp>(</rp><rt>Structured Data </rt><rp>)</rp></ruby>。</p>
<h2>0X02: Structured Data</h2>
<p>结构化数据一个大概念，它指一切以某种特定结构组织的数据，例如一个数据库、一张数据表。实际上我们常用的词 SQL — Structured Query Language 就蕴含着结构化数据的思想。</p>
<p>在 Web 语境下说结构化数据，主要说的是以某种特定的数据结构呈现页面的内容。例如一个介绍了一张菜谱的网页，视觉上的效果各有不同，但其中的重要信息是一致的：菜名、原料与用量、烹制顺序、烹制时间等。结构化数据通过某种标准，帮助各个网站对其内容做好标记，方便第三方服务抓取、分析与展示。</p>
<p>结构化数据是一种思想，具体实现途径有多种，例如<a href="https://www.w3.org/TR/microdata/"><ruby>微数据<rp>(</rp><rt>Microdata</rt><rp>)</rp></ruby></a>，<a href="http://microformats.org"><ruby>微格式<rp>(</rp><rt>Microformat</rt><rp>)</rp></ruby></a>，<a href="https://json-ld.org/">JSON-LD</a>，RDFa 等。但不论使用哪种途径，都需要一个统一的标准为<ruby>事物<rp>(</rp><rt>Thing</rt><rp>)</rp></ruby>制定必须的属性集合，例如一辆汽车的结构化属性（价格、排量等），一本书的结构化属性（书名、作者、出版时间等）。</p>
<p>互联网上，<ruby>事实上的<rp>(</rp><rt>de-facto</rt><rp>)</rp></ruby>结构化数据标准是 <a href="https://schema.org">Schema.org</a>，它制定了许多标准，并且仍然在添加更多的标准，例如下图是 Schema.org 制定的一张菜谱需要的结构内容：</p>
<p><figure class="pswp-item" style="flex: 72.84382284382285" data-width="1250" data-height="858"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/98cd42a165c0deea490c762572a3874a.png" alt="Scheme.org - Recipe" /><figcaption>Scheme.org - Recipe</figcaption></figure></p>
<p>可以想象，如果需要一个网页展示的菜谱更容易被机器理解，就需要在网页中显式地指明上图中列出的数据，而且还是以某种开放的、大家都接受的格式。</p>
<p>需要特别说明的是，虽然结构化数据经常和 SEO 一块儿讨论，但结构化数据的作用绝不只是 SEO，它是“讲究的 HTML”所必备的。</p>
<p>现在，我们来聊聊技术细节。对技术不敏感的读者可以止步于此了。</p>
<h2>0X03: Microdata</h2>
<p>Microdata，或者微数据，是 HTML 5 引入的。它扩展了 HTML 的属性集，通过 <code>itemscope</code>、<code>itemtype</code>、<code>itemprop</code> 加上 <code>itemid</code> 与 <code>itemref</code> 来界定结构化数据的类型与数据来源。</p>
<p>给标签加上 <code>itemscope</code> 属性，代表这是一个事物（item）：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">div</span> <span class="na">itemscope</span><span class="p">&gt;</span>
    ...
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div>
<p>标记了 <code>itemscope</code> 的 DOM 树中就应该包含这个事物的信息。这个事物到底是什么？我们可以使用 Scheme.org 所定义的格式：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">div</span> <span class="na">itemscope</span> <span class="na">itemtype</span><span class="o">=</span><span class="s">&quot;https://schema.org/Book&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>书名：<span class="p">&lt;</span><span class="nt">span</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">&gt;</span>挪威的森林<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>作者：<span class="p">&lt;</span><span class="nt">span</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;author&quot;</span><span class="p">&gt;</span>村上春树<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    ...
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div>
<p>带有 <code>itemscope</code> 的元素下面的子元素通过 <code>itemprop</code> 指定数据名称，标签的内容就是这个属性的值。当然 <code>itemprop</code> 也应该在文档中查询对应的事物得到。</p>
<p><code>itemid</code> 与 <code>itemref</code> 用于无法在同一个 <code>itemscope</code> 中指定所有结构化数据的情况。例如：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">div</span> <span class="na">itemscope</span> <span class="na">itemref</span><span class="o">=</span><span class="s">&quot;book-1-attr-1 book-1-attr-2&quot;</span> <span class="na">itemtype</span><span class="o">=</span><span class="s">&quot;https://schema.org/Book&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>书名：<span class="p">&lt;</span><span class="nt">span</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">&gt;</span>挪威的森林<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    ...
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 在 itemscope 外声明 --&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;book-1-attr-1&quot;</span><span class="p">&gt;</span>书名：<span class="p">&lt;</span><span class="nt">span</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;author&quot;</span><span class="p">&gt;</span>村上春树<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;book-1-attr-2&quot;</span><span class="p">&gt;</span>价格：<span class="p">&lt;</span><span class="nt">span</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;price&quot;</span><span class="p">&gt;</span>$20<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div>
<p>VOID 1.2 版本添加了 Microdata 支持，你可以在检查元素中查看一下。你看到的这个页面使用的是 <a href="http://schema.org/Article">http://schema.org/Article</a> 这个 <code>itemtype</code>，完整的属性集：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">article</span> <span class="na">itemscope</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">itemtype</span><span class="o">=</span><span class="s">&quot;http://schema.org/Article&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h1</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">&gt;</span>Semantic Web：结构化数据<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span> <span class="na">hidden</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;headline&quot;</span><span class="p">&gt;</span>...<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">time</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&quot;2019-02-01T16:31:14Z&quot;</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;datePublished&quot;</span><span class="p">&gt;</span>2019-02-01<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;articleBody&quot;</span><span class="p">&gt;</span>...<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;dateModified&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;2019-02-01T16:31:14Z&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">span</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;author&quot;</span><span class="p">&gt;</span>熊猫小A<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">hidden</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;image&quot;</span> <span class="na">itemscope</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">itemtype</span><span class="o">=</span><span class="s">&quot;https://schema.org/ImageObject&quot;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;url&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;https://blog.imalan.cn/usr/uploads/2019/02/1792839130.png&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">hidden</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;publisher&quot;</span> <span class="na">itemscope</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">itemtype</span><span class="o">=</span><span class="s">&quot;https://schema.org/Organization&quot;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;name&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;熊猫小A的博客&quot;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;logo&quot;</span> <span class="na">itemscope</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">itemtype</span><span class="o">=</span><span class="s">&quot;https://schema.org/ImageObject&quot;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;url&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;https://secure.gravatar.com/avatar/1741a6eef5c824899e347e4afcbaa75d?s=256&amp;amp;r=&amp;amp;d=&quot;</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">itemscope</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="na">itemprop</span><span class="o">=</span><span class="s">&quot;mainEntityOfPage&quot;</span> <span class="na">itemtype</span><span class="o">=</span><span class="s">&quot;https://schema.org/WebPage&quot;</span> <span class="na">itemid</span><span class="o">=</span><span class="s">&quot;https://blog.imalan.cn/archives/259/&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
</pre></div>
<h2>0X04: Microformat</h2>
<p>Microformat（也叫 μF） 诞生已经 14 年了。它相对 Microdata 而言要更简单一些：使用 class 与 rel 来指定数据类型与数据名。</p>
<p>虽说互联网上有事实上的标准 Schema.org，但你实际上是可以自定义任何 itemtype 作为 Microdata 的。Microformat 则与此不同，你基本上只能使用 <a href="http://microformats.org/wiki/Main_Page">Wiki</a> 上列出来的东西，要想使用新的则需要经过冗长的流程。Microformat 基本上已经是过去时了，所以并不十分推荐。</p>
<p>以一篇文章为例，最适合的类型是 <a href="http://microformats.org/wiki/hentry">hentry</a>：</p>
<p><figure class="pswp-item" style="flex: 67.99065420560747" data-width="582" data-height="428"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/f72108816423d4cf89289b14ddf9fda1.png" alt="Microformat - hentry" /><figcaption>Microformat - hentry</figcaption></figure></p>
<p>在原有的结构上添加一些 class 名即可完成 Microformat 标注：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;h-entry&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">h1</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;p-name&quot;</span><span class="p">&gt;</span>Semantic Web: 结构化数据<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Published by <span class="p">&lt;</span><span class="nt">a</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;p-author h-card&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;https://blog.imalan.cn&quot;</span><span class="p">&gt;</span>熊猫小A<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
     on <span class="p">&lt;</span><span class="nt">time</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;dt-published&quot;</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&quot;2019-02-01T16:31:14Z&quot;</span><span class="p">&gt;</span>2019-02-01<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">p</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;p-summary&quot;</span><span class="p">&gt;</span>...<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;e-content&quot;</span><span class="p">&gt;</span>
    ...
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
</pre></div>
<p>Microformat 的好处是相对简单，在原始的页面上应用少量的更改即可。并且由于它使用类名作为标志，可以在一定程度上指导页面开发。</p>
<p>不过值得一提的是，Google 的<a href="https://developers.google.com/search/docs/guides/intro-structured-data">结构化数据接入指导</a>中并没有提及它是否支持 Microformat，因此综合考虑下我并没有为本站添加 Microformat 支持。</p>
<h2>0X05: JSON-LD</h2>
<p>JSON-LD 是 JSON for Linking Data 的缩写。我挺喜欢它官网的 slogan：</p>
<blockquote><p>Data is messy and disconnected. JSON-LD organizes and connects it, creating a better Web.</p>
</blockquote>
<p>当然，每一种结构化数据手段都是为了“creating a better Web”。JSON-LD 是相对较新的东西，它采用 JSON 格式在页面中展示页面信息，例如：</p>
<div class="highlight"><pre><span></span><span class="err">&lt;script</span> <span class="err">type=</span><span class="s2">&quot;application/ld+json&quot;</span><span class="err">&gt;</span>
<span class="p">{</span>
  <span class="nt">&quot;@context&quot;</span><span class="p">:</span> <span class="s2">&quot;https://schema.org/&quot;</span><span class="p">,</span>
  <span class="nt">&quot;@type&quot;</span><span class="p">:</span> <span class="s2">&quot;Recipe&quot;</span><span class="p">,</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Grandma&#39;s Holiday Apple Pie&quot;</span><span class="p">,</span>
  <span class="nt">&quot;author&quot;</span><span class="p">:</span> <span class="s2">&quot;Elaine Smith&quot;</span><span class="p">,</span>
  <span class="nt">&quot;image&quot;</span><span class="p">:</span> <span class="s2">&quot;http://......&quot;</span><span class="p">,</span>
  <span class="nt">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;A classic apple pie.&quot;</span>
<span class="p">}</span>
<span class="err">&lt;/script&gt;</span>
</pre></div>
<p>这段代码可以放在页面的 head 中，也可以放在页面内。Google 明确说明了它支持动态注入的 JSON-LD 数据，也就是说可以放心地在页面中使用 AJAX 等技术：</p>
<blockquote><p>Google can read JSON-LD data when it is dynamically injected into the page's contents, such as by JavaScript code or embedded widgets in your content management system.</p>
</blockquote>
<p>使用 JSON-LD 的好处是完全不用更改原 HTML 结构，只需要在页面中添加这部分数据即可。坏处是它使用独立的一块 JSON 来展示数据，使页面数据有一部分冗余。</p>
<p>注意，JSON-LD 是 Google 推荐的结构化数据标注方式。另还有 RDFa 等标注方式，现在用得较少了，就不单独说明了。</p>
<h2>0X06: In real world</h2>
<p>虽然 Google 在「尝试搞明白网页上都在说什么」这件事上做得已经相当不错了，但充分地使用结构化数据为网页做好标记仍然是有意义的。一个明显的优势是做好了标注的网页在 Google 的搜索结果中<strong>可能</strong>会有更好的展示。</p>
<p><figure class="pswp-item" style="flex: 63.308457711442784" data-width="509" data-height="402"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/d5b479add1aa60d960527a205068d779.png" alt="一个菜单搜索结果" /><figcaption>一个菜单搜索结果</figcaption></figure></p>
<p>Google 在<a href="https://developers.google.com/search/docs/guides/mark-up-content">这里</a>列举了它所支持的部分类型，截止本文写作（2019-02-01），支持的类型与可能的结果展示方式如下：</p>
<p><figure class="pswp-item" style="flex: 82.00899550224888" data-width="1094" data-height="667"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/8946acbe0ab019c65c007c9ea38be944.png" alt="Google 支持的标注类型" /><figcaption>Google 支持的标注类型</figcaption></figure></p>
<p>对每种数据类型，在提供了所有<ruby>必须<rp>(</rp><rt>required</rt><rp>)</rp></ruby>信息的前提下，Google 提倡提供尽量多的<ruby>可用<rp>(</rp><rt>optional</rt><rp>)</rp></ruby>信息。但是值得注意的是，Google 有他自己的一套要求，与 Scheme.org 的要求并不一定一致。</p>
<p>Google 提供了一个<a href="https://search.google.com/structured-data/testing-tool">结构化数据检查工具</a>，你可以输入网址或者粘贴代码来查看网页标记是否合规，例如你正在看到的这个页面检测结果如下：</p>
<p><figure class="pswp-item" style="flex: 93.20388349514563" data-width="1920" data-height="1030"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/a45b968fd58627bb866642ba3cb7527c.png" alt="测试结果" /><figcaption>测试结果</figcaption></figure></p>
<p>至于是否需要在页面中同时应用多种标记，例如同时使用 JSON-LD 与 Microdata，这个视情况而定。只要多个标记的标记内容都是一致的，Google 是可以接受的，但是若标记内容不同，则可能被判定为重复的内容，这不利于 SEO。以我自己的实践来说，考虑到浏览器与搜索引擎支持，目前在博客中支持了 Microdata。JSON-LD 稍后支持。</p>
<p>除了对网页数据进行语义化标注，Google 还对 GMail <a href="https://developers.google.com/gmail/markup/getting-started">做了支持</a>。如果你曾经使用过 Google 出品的 Index 这个产品，会发现 Google 对邮件的内容分析做得相当好，这一部分是机器学习的功劳，一部分仰赖各个厂商对邮件的标记。例如机票、酒店预订等通知邮件，通过良好的标记都可以帮助 Google 在产品中更直观地展示邮件中的重要信息，甚至帮助用户订车、安排日程等。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://ahrefs.com/blog/what-is-structured-data/">https://ahrefs.com/blog/what-is-structured-data/</a></li>
<li><a href="https://www.wikiwand.com/en/Semantic_Web">https://www.wikiwand.com/en/Semantic_Web</a></li>
<li><a href="https://www.w3.org/TR/microdata/">https://www.w3.org/TR/microdata/</a></li>
<li><a href="https://lepture.com/zh/2015/fe-microdata">https://lepture.com/zh/2015/fe-microdata</a></li>
<li><a href="http://microformats.org/">http://microformats.org/</a></li>
<li><a href="https://json-ld.org/">https://json-ld.org/</a></li>
</ul>
<hr><div class="footnotes"><ol><li id="fn_1">摘自维基百科 <a no-style href="#fn_ref_1">↩</a></li><li id="fn_2">一类读出屏幕内容的软件，一般为视觉障碍的用户服务 <a no-style href="#fn_ref_2">↩</a></li></ol></div></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/259/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/323/" target="_self">Typecho Theme Q 纪念碑</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/323/" target="_self">
                <time class="text-uppercase">
                    January 24 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>最初，我使用 Bootstrap 框架仿照好奇心日报的样式写出了第一版（已经没有截图了），然后又将其大改为类似 Typlog 的样式。全程保持自用。</p>
<p>目前已经不再维护，并且我自己也没有在使用它，因此这个页面只是一个墓碑，用来展示一些页面效果。专门开一个演示站太繁琐了。</p>
<h2>桌面端</h2>
<p><figure class="pswp-item" style="flex: 78.30342577487765" data-width="1920" data-height="1226"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/ac8b450a8b2c8e7c857fd19bc6d9eeaa.png" alt="首页" /><figcaption>首页</figcaption></figure></p>
<p><figure class="pswp-item" style="flex: 78.30342577487765" data-width="1920" data-height="1226"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/739ca4b22387daed3c692d86ba72c72c.png" alt="文章页" /><figcaption>文章页</figcaption></figure></p>
<p><figure class="pswp-item" style="flex: 78.30342577487765" data-width="1920" data-height="1226"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/a3293ed4162a41502cf770da515bec03.png" alt="归档页" /><figcaption>归档页</figcaption></figure></p>
<p><figure class="pswp-item" style="flex: 78.30342577487765" data-width="1920" data-height="1226"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/292d44be2650ecfd72358e6a707e4ac0.png" alt="友链页" /><figcaption>友链页</figcaption></figure></p>
<h2>移动端</h2>
<p>当然，这个主题是响应式的，以下是在 iOS Safari 上的截图。</p>
<div class="photos">
<figure class="pswp-item" style="flex: 23.08402585410896" data-width="500" data-height="1083"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/af426facbd1b6d2ec4f5ee4314bd3e79.png" alt="首页" /><figcaption>首页</figcaption></figure>
<figure class="pswp-item" style="flex: 23.08402585410896" data-width="500" data-height="1083"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/fa7118ddf88526bd0eef8b636a4390ab.png" alt="文章页" /><figcaption>文章页</figcaption></figure>
<figure class="pswp-item" style="flex: 23.08402585410896" data-width="500" data-height="1083"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/afbb95c3950e6db117ccd00de0a00183.png" alt="归档页" /><figcaption>归档页</figcaption></figure></div></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/323/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/251/" target="_self">Gulp 入门记</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/251/" target="_self">
                <time class="text-uppercase">
                    January 23 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>本文以一例介绍我上手 Gulp 之过程。与之前的文章<a href="https://blog.imalan.cn/archives/243/">初识 Sass | SCSS</a>相同，这篇文章也是开发 VOID 主题过程的技术笔记。</p>
<p>我一直都为一件事情感到头疼：前端项目的资源缓存问题。页面有所变化后，理论上对应的静态资源例如 JS、CSS 也应该立即更新，但实际上并不那么简单。现代浏览器都有缓存机制，使浏览器不会立即拉取最新的静态文件，以节省网络开销；若站点启用了 CDN，CDN 层面也有缓存机制，而且一般会更长，导致请求不能及时回源。结果就是页面是新页面，样式与业务逻辑却是老的。</p>
<p>一种解决方式是通过后缀告知浏览器应该刷新资源：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;/style/main.css?v=1.123&quot;</span><span class="p">&gt;</span>
</pre></div>
<p>其中的 <code>?v=1.123</code> 代表了静态资源的版本号，如果浏览器足够聪明的话，一旦该版本号有所变化就会重新请求资源，但实际上不同浏览器的处理方式不同。而且许多 CDN 厂商对 v 参数是忽略的。</p>
<p>另一种解决方法是把版本号写入到文件路径中：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;/style/main.1.123.css&quot;</span><span class="p">&gt;</span>
</pre></div>
<p>在 RAW 主题与 VOID 的初期几个版本中我就是用的这种方法。这是一种可行的解决方法，它无视浏览器的缓存机制，因为一旦版本号变换就相当于资源路径变化，这样会强制浏览器刷新。但有一点不足是一旦项目版本变化，不论静态资源本身有没有改动，其路径都有改变，这就带来了不必要的请求开销，没有充分利用浏览器缓存。</p>
<p>目前广泛采用的解决方式是将文本摘要算法引入到静态资源的版本管理中，页面中引入的静态文件路径形如：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;/style/main-{{hash}}.css&quot;</span><span class="p">&gt;</span>
</pre></div>
<p>其中 <code>{{hash}}</code> 指的是文件的哈希值。哈希作为文件的摘要，与文件内容对应，文件改变哈希改变、文件不变哈希不变。这种方法既解决了资源更新的问题，也能充分利用浏览器与 CDN 缓存。实际上，一旦采用这种方式，可以为资源设置很长的缓存过期时间。</p>
<p>我最初接触 Gulp 正是为了自动化地实现这一过程。</p>
<h2>什么是 Gulp</h2>
<p>Gulp 是一个自动化构建工具，开发者可以通过制定一系列规则（gulpfile.js）来搭建一个处理的工作流（workflow），自动化某些重复性工作：例如 CSS 预处理、压缩、JS 混淆加密等等。同时 Gulp 提供了大量的插件帮助开发者完成这一过程。</p>
<p>首先安装 NodeJS，之后在项目目录下使用 <code>npm init</code> 初始化一个项目。之后安装 Gulp：</p>
<div class="highlight"><pre><span></span>npm install gulp --global
npm install gulp --save-dev
</pre></div>
<p>这条命令会在当前目录安装 gulp，并且将此信息保存到 package.json 中作为开发依赖。在当前目录下新建一个 gulpfile.js，在其中键入代码：</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gulp</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;gulp&#39;</span><span class="p">);</span>

<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;defualt&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello World!&#39;</span><span class="p">);</span>
<span class="p">})</span>
</pre></div>
<p>然后在终端中运行 <code>gulp</code>。<code>gulp.task()</code> 声明了一个名为 <code>default</code> 的任务，它的作用是在控制台输出 Hello World，这就是一个最简单的示例，我们要做的便是根据需要自己搭建 <code>function(){}</code> 中的内容。</p>
<p>Gulp 中有管道（pipe）的概念，它面向的是一个文件流（stream）。一个典型的 Gulp 任务包含了这样的过程：读取源文件 → 执行操作 1 → 执行操作 2 → ··· → 执行操作 n → 输出。</p>
<p>其中，读取源文件使用 <code>gulp.src</code> 完成：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;src/assets/libs/**/*.js&#39;</span><span class="p">]);</span>
</pre></div>
<p>这行代码将 src/assets/libs 目录及其子目录下的所有 JS 文件读了进来，然后什么也没干。传入 <code>gulp.src()</code> 的是一个字符串数组，可以使用多种匹配模式。例如：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;src/assets/libs/**/*.js&#39;</span><span class="p">,</span> <span class="s1">&#39;!src/assets/libs/mathjax&#39;</span><span class="p">,</span> <span class="s1">&#39;!src/assets/libs/mathjax/**/*&#39;</span><span class="p">])</span>
</pre></div>
<p>这行代码除了加载 src/assets/libs 目录及其子目录下的所有 JS 文件，还从中剔除了 src/assets/libs/mathjax 子目录及其下的文件。</p>
<p>执行操作使用 <code>.pipe()</code> 方法串联，例如：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;src/assets/libs/**/*.js&#39;</span><span class="p">])</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">task</span><span class="p">());</span>
</pre></div>
<p>传入 <code>pipe()</code> 的是某个操作。这个操作可以自己定义，也可以通过安装 Gulp 插件获得。</p>
<p>输出文件也属于一种操作，因此也被包裹在 <code>pipe()</code> 方法中：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;src/assets/libs/**/*.js&#39;</span><span class="p">])</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">task</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="s1">&#39;build/&#39;</span><span class="p">));</span>
</pre></div>
<p>最终的结果便是将那些 JS 处理后输出到 build 文件夹下。</p>
<p>以上是对 Gulp 的大概了解，接下来看看如何使用 Gulp 为静态文件加上哈希戳，并且同时替换页面中的引用路径。</p>
<h2>利用 Gulp 为静态文件加戳</h2>
<p>Gulp 社区是很强大的，它提供了数量巨大的插件供开发者使用。本例中，用到了 <code>gulp-rev</code> 与 <code>gulp-rev-collector</code> 两个插件。</p>
<p>首先安装 gulp 与这两个插件，在项目目录下：</p>
<div class="highlight"><pre><span></span>npm install gulp-rev gulp-rev-collector --save-dev
</pre></div>
<p>为了清除旧版文件与删除临时文件，再安装一个用于删除的插件 <code>del</code>：</p>
<div class="highlight"><pre><span></span>npm install del --save-dev
</pre></div>
<p>设有如下的目录结构：</p>

<pre><code>dev
   |-- app.js
   |-- app.css
   |-- index.html
build</code></pre>
<p>目的是将 app.js，app.css 加哈希戳，输出到 build 目录下，并替换 index.html 中对这两个文件的引用地址为加戳后的路径，将替换后的 index.html 也输出到 build 目录下，如此实现了开发目录与构建目录的分离。</p>
<p>容易看出，这是两个步骤。一是计算静态文件的哈希，并重命名它们；二是替换 index.html 中的引用。实际上 Gulp 也是这么处理的。</p>
<p>首先在 gulpfile.js 中引入 Gulp 与对应插件。</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gulp</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;gulp&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">rev</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;gulp-rev&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">revCollector</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;gulp-rev-collector&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">del</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;del&#39;</span><span class="p">);</span>
</pre></div>
<p>声明一个清理原 build 文件夹的任务：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;clean:build&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="k">return</span> <span class="nx">del</span><span class="p">([</span><span class="s1">&#39;build&#39;</span><span class="p">]);</span>
<span class="p">});</span>
</pre></div>
<p>声明一个加戳的任务：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;md5&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span>  <span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;dev/*.js&#39;</span><span class="p">,</span> <span class="s1">&#39;dev/*.css&#39;</span><span class="p">])</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">rev</span><span class="p">())</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="s1">&#39;build/&#39;</span><span class="p">))</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">rev</span><span class="p">.</span><span class="nx">manifest</span><span class="p">())</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="s1">&#39;temp/&#39;</span><span class="p">));</span>
<span class="p">});</span>
</pre></div>
<p>尝试使用 <code>gulp md5</code> 执行 <code>md5</code> 这个任务，可以看到初步有一些小变化，目录变成了（省略了一些不重要的目录）：</p>

<pre><code>dev
   |-- app.js
   |-- app.css
   |-- index.html
build
   |-- app-d41d8cd98f.js
   |-- app-d41d8cd98f.css
temp
   |-- rev-manifest.json</code></pre>
<p>一者，build 目录下已经生成了加戳的静态文件，二者，多出了 temp/rev-manifest.json 这个文件。打开该文件，可以看到如下内容：</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;app.css&quot;</span><span class="p">:</span> <span class="s2">&quot;app-d41d8cd98f.css&quot;</span><span class="p">,</span>
  <span class="nt">&quot;app.js&quot;</span><span class="p">:</span> <span class="s2">&quot;app-d41d8cd98f.js&quot;</span>
<span class="p">}</span>
</pre></div>
<p>实际上这个文件以键值对的形式存储了文件名的映射关系。正是因为有这个文件我们才能进行下一步：静态资源引用路径替换。</p>
<p>在 gulpfile.js 中声明一个替换任务：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span>  <span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;temp/*.json&#39;</span><span class="p">,</span> <span class="s1">&#39;dev/index.html&#39;</span><span class="p">])</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">revCollector</span><span class="p">())</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="s1">&#39;build/&#39;</span><span class="p">));</span>
<span class="p">});</span>
</pre></div>
<p>执行这个任务：<code>gulp replace</code>，目录结构变更为：</p>

<pre><code>dev
   |-- app.js
   |-- app.css
   |-- index.html
build
   |-- app-d41d8cd98f.js
   |-- app-d41d8cd98f.css
   |-- index.html
temp
   |-- rev-manifest.json</code></pre>
<p><code>dev/index.html</code> 中的引用形如：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;./app.css&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;./app.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
<p>而 <code>build/index.html</code> 中的内容形如：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;./app-d41d8cd98f.css&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;./app-d41d8cd98f.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
<p>可见替换已经成功了。</p>
<p>以上通过手动执行每个任务看到了整个过程。是时候将它们串联起来了。</p>
<h2>Gulp 任务串行与并行</h2>
<p>以上的任务是一个明显的串行关系：清理 build 目录 → 文件加戳输出 → 引用路径替换输出。Gulp 默认对所有的任务以最大并发的方式执行，若要得到串行的任务关系，需要显式地指定。</p>
<p>Gulp 4 之前可以通过这样的方式将任务串起来：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;build&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;task_1&#39;</span><span class="p">,</span> <span class="s1">&#39;task_2&#39;</span><span class="p">]);</span>  <span class="c1">// task_1 与 task_2 中需要将文件流 return</span>
</pre></div>
<p>Gulp 4 起以上方式不再可行。用以替换的，Gulp 提供了两个方法用以显式地指定并发与串行关系：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">parallel</span><span class="p">(</span><span class="s1">&#39;task_1&#39;</span><span class="p">,</span> <span class="s1">&#39;task_2&#39;</span><span class="p">,</span> <span class="s1">&#39;task_3&#39;</span><span class="p">);</span>  <span class="c1">// 并发</span>
<span class="nx">gulp</span><span class="p">.</span><span class="nx">series</span><span class="p">(</span><span class="s1">&#39;task_1&#39;</span><span class="p">,</span> <span class="s1">&#39;task_2&#39;</span><span class="p">,</span> <span class="s1">&#39;task_3&#39;</span><span class="p">);</span> <span class="c1">// 串行</span>
</pre></div>
<p>它们可以嵌套：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">series</span><span class="p">(</span><span class="s1">&#39;task_1&#39;</span><span class="p">,</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">parallel</span><span class="p">(</span><span class="s1">&#39;task_2&#39;</span><span class="p">,</span> <span class="s1">&#39;task_3&#39;</span><span class="p">),</span> <span class="s1">&#39;task_4&#39;</span><span class="p">);</span>
</pre></div>
<p>效果是先执行 task_1，然后并发执行 task_2、task_3，然后执行 task_4。</p>
<p>对本文中的例子，声明一个总的 build 任务：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;build&#39;</span><span class="p">,</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">series</span><span class="p">(</span><span class="s1">&#39;clean:build&#39;</span><span class="p">,</span> <span class="s1">&#39;md5&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">));</span>
</pre></div>
<p>直接执行该任务即可看到效果。</p>
<h2>监视更改</h2>
<p>使用 <code>gulp.watch()</code> 可以实现监视文件，当文件更改时立即执行任务。</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;watch&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">watch</span><span class="p">(</span><span class="s1">&#39;dev/*&#39;</span><span class="p">,</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">series</span><span class="p">(</span><span class="s1">&#39;clean:build&#39;</span><span class="p">,</span> <span class="s1">&#39;md5&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">));</span>
<span class="p">});</span>
</pre></div>
<p>当 dev 目录下的文件更改时，立即执行 <code>'clean:build', 'md5', 'replace'</code> 。</p>
<h2>拷贝文件</h2>
<p>其实没必要单独拎出来说，但其中有一个 trick，记录一下。若有这样的目录结构：</p>

<pre><code>dev
   |-- vendor
       |-- lib1
           |-- lib1.js
           |-- lib1.css
       |-- lib2
           |-- lib2.js
           |-- lib2.css
       |-- lib3
           |-- lib3.js
           |-- lib3.css
   |-- app.js
   |-- app.css
   |-- index.html
build</code></pre>
<p>目的是将 dev/vendor 中的<strong>所有</strong>文件夹完整拷贝至 build 目录。实际上，Gulp 的拷贝就是不执行任何中间操作的 src 与 dest，因此很容易：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;move&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">(</span><span class="s1">&#39;dev/vendor/**/*&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="s1">&#39;build/&#39;</span><span class="p">));</span>
<span class="p">})</span>
</pre></div>
<p>但是，若要仅把 dev/vendor/lib1 与 dev/vendor/lib2 文件夹拷贝至 build 目录，这样的代码是错误的：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;move&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;dev/vendor/lib1/*&#39;</span><span class="p">,</span> <span class="s1">&#39;dev/vendor/lib2/*&#39;</span><span class="p">])</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="s1">&#39;build/&#39;</span><span class="p">));</span>  <span class="c1">// 丢失目录结构</span>
<span class="p">})</span>
</pre></div>
<p>因为你会看到这样的结果：</p>

<pre><code>build
    |-- lib1.js
    |-- lib1.css
    |-- lib2.js
    |-- lib2.css</code></pre>
<p>很正常的，丢失了目录结构。要解决这个问题，需要用到 <code>gulp.src()</code> 的 <code>base</code> 参数：</p>
<div class="highlight"><pre><span></span><span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">&#39;move&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">([</span><span class="s1">&#39;dev/vendor/lib1/*&#39;</span><span class="p">,</span> <span class="s1">&#39;dev/vendor/lib2/*&#39;</span><span class="p">],</span> <span class="p">{</span>
                <span class="nx">base</span><span class="o">:</span> <span class="s1">&#39;dev/vendor/&#39;</span>
            <span class="p">})</span>
        <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="s1">&#39;build/&#39;</span><span class="p">));</span>  <span class="c1">// 保持目录结构</span>
<span class="p">})</span>
</pre></div>
<p>则可以得到正确的结果：</p>

<pre><code>build
    |-- lib1
        |-- lib1.js
        |-- lib1.css
    |-- lib2
        |-- lib2.js
        |-- lib2.css</code></pre>
<h2>总结</h2>
<p>以上介绍了我上手 Gulp 的一些过程。VOID 主题现在已经使用 Gulp 自动化构建，效果妙不可言。其使用的 gulpfile.js 见 <a href="https://github.com/AlanDecode/Typecho-Theme-VOID/blob/master/gulpfile.js">GitHub</a>，除了静态文件加戳，还有 CSS 预处理、压缩、合并，JS 混淆、压缩、合并等流程，若有错漏还请赐教。</p>
<p>昨天晚上到今天上午我一直在研究 Gulp，目前只是初步的上手而已。这样的工具，相见恨晚啊。</p>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/251/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/247/" target="_self">VOID：现在可以公开的情报</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/247/" target="_self">
                <time class="text-uppercase">
                    January 21 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>作为计算机术语时，VOID 的意思是「无类型」。在本文中，它是由我开发并开源的第二款 Typecho 主题。</p>
<p>写本文时距离我发布上一款也是第一款主题 RAW 并不久。一开始我对 RAW 很满意，但它逐渐成为了我的试验田、游乐场，而不是一个可以给大家使用的作品。一团乱麻的代码，不甚合理的设计，冗余过度实用不足的功能集，让维护与进一步开发变得没有乐趣可言。</p>
<p>回头想想，这几个月通过开发与维护 RAW 也学到了不少东西，认识了不少朋友。当它无法为我带来更多的乐趣时，我意识到 RAW 在我这里的使命已经完成，是时候前进了。</p>
<div class="notice">博客交流群已建立，目前处于无人打理的自由水状态，欢迎进群讨论：777536599。Telegram 群组：<a href="http://t.me/imalanblog">进群</a></div><hr>
<blockquote><p>🐒 猴子打字机原理的产物</p>
</blockquote>
<p>VOID 是我从头开发的全新作品。开发过程中借鉴了 Ghost 默认主题 <a href="https://demo.ghost.io/">Casper</a> 与水八口开发的 Bitcron 主题 <a href="https://blog.shuiba.co/bitcron-theme-card">Card</a>。</p>
<p>VOID 中图片的展示占了很大的比重，首页上文字量很少，一眼看过去是十来张图片。另外，你或许会有这样的感觉：VOID 这个主题方方正正的，显得很端庄的样子。确实是这样的，主题中圆角很少，不规则的图形也很少。</p>
<p>这其实是我自己动的一点小心思。</p>
<p>既然是挂上了 MIT 许可的开源项目，自然就没有立场干涉别人怎么用。但多少是自己的作品，心底里对别人如何使用它还是有所期待的。DIYgod 在<a href="https://diygod.me/open-source-project-donation/">关于开源项目赞助这件事</a>里提到 DPlayer：</p>
<blockquote><p>...再加上用户大多是盗版站和小黄站，这曾一度让我产生了弃坑的想法。</p>
</blockquote>
<p>若要我说出最诚实的想法：我希望使用这些主题的博主，能认真地多写几篇正经文章，这才是独立博客的精髓。一两句话的牢骚，大可以去微博与 Twitter 上说；花花绿绿的代刷广告与盗版采集还是免了吧。</p>
<p>「媒介即讯息」。虽然这句话放在这里不甚恰当，我实际要表达的意思是主题的形式能在一定程度上影响作者的产出。VOID 的排版很规整，可以用来修改的空间并不大，甚至连个广告都很难找到合适的地方放。再加上图片占了很大比重，若是不认真对待，恐怕用这个主题的结果就很难看了。</p>
<p>这是自损八百的做法：我丢失了一部分潜在的使用者。但并非不值得。</p>
<p>去除了繁杂的功能、版式，最终还是回归到文本上来。如何使网页可用性更高是一个很大的话题，涉及到排版、无障碍等等方面。VOID 的文字样式使用 Lepture 的项目 <a href="https://github.com/lepture/yue.css">yue.css</a>，经过我的反复考虑，这个 CSS 集应用到内容块上效果很好。有一个小的改动：原项目的字体默认大小是 18px，综合考虑下 VOID 使用了 17px。相比起 RAW，以及其他许多主题，应该能感觉到 VOID 的文字可读性要高得多。</p>
<p>无障碍这一块 VOID 现在做得不好。主要是因为我主业并非前端，全凭兴趣，某些<a href="https://lepture.com/zh/2015/fe-aria-label">基础修养</a>尚有欠缺。这将在后续的维护中逐步提升。</p>
<p>我不准备在这篇文章中详叙 VOID 的使用方法与功能，罗列功能是一件很无聊的事情。这部分内容请参阅主题的 GitHub 主页：<a href="https://github.com/AlanDecode/Typecho-Theme-VOID/blob/master/README.md">AlanDecode/Typecho-Theme-VOID</a>，功能更新与 bug 修复记录请查看 GitHub 上的<a href="https://github.com/AlanDecode/Typecho-Theme-VOID/commits/master">提交记录</a>。</p>
<div class="notice">鉴于目前我没有再使用 VOID，这里放上几张截图，供参考</div><div class="photos">
<figure class="pswp-item" style="flex: 83.78537735849056" data-width="1421" data-height="848"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/6678e79cf6385b2059c8475e190dfdbc.png" alt="首页" /><figcaption>首页</figcaption></figure>
<figure class="pswp-item" style="flex: 83.84433962264151" data-width="1422" data-height="848"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/7d1187ef2bc56f260f6de8926472adda.png" alt="文章页" /><figcaption>文章页</figcaption></figure></div><div class="photos">
<figure class="pswp-item" style="flex: 83.72641509433963" data-width="1420" data-height="848"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/c9e6981891480637b7cb939617ffed38.png" alt="友链" /><figcaption>友链</figcaption></figure>
<figure class="pswp-item" style="flex: 83.72641509433963" data-width="1420" data-height="848"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/5135f790142522e86a54b264e04741d7.png" alt="归档" /><figcaption>归档</figcaption></figure></div><div class="photos">
<figure class="pswp-item" style="flex: 83.78537735849056" data-width="1421" data-height="848"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/db0113823c6a8ac41032322eadd1902c.png" alt="图片排版" /><figcaption>图片排版</figcaption></figure></div><p>VOID 是响应式的：</p>
<div class="photos">
<figure class="pswp-item" style="flex: 28.11094452773613" data-width="375" data-height="667"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/d952d29c7f422b56271755cfed0f5e09.png" alt="首页-竖屏" /><figcaption>首页-竖屏</figcaption></figure>
<figure class="pswp-item" style="flex: 28.11094452773613" data-width="375" data-height="667"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/cafa74b0e75b57b3de10815b7eaabdef.png" alt="文章页-竖屏" /><figcaption>文章页-竖屏</figcaption></figure></div><div class="photos">
<figure class="pswp-item" style="flex: 28.11094452773613" data-width="375" data-height="667"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/242022de055561a9804a2dbb2054260b.png" alt="文章目录-竖屏" /><figcaption>文章目录-竖屏</figcaption></figure>
<figure class="pswp-item" style="flex: 28.11094452773613" data-width="375" data-height="667"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/5c69b80f04c29507f01c137fd2bb15d4.png" alt="导航-竖屏" /><figcaption>导航-竖屏</figcaption></figure></div><hr>
<p>其实基本的思考是：独立博客到底应该是什么样的。</p>
<p>这个问题我无法回答，恐怕叱咤独立博客界 17 年之久的 <a href="https://daringfireball.net/">Daring Fireball</a> 作者 John Gruber 也给不出让所有人信服的回答。这个问题大概本来就没有答案。</p>
<p>互联网发展到现在，带宽、内容丰富程度都与 20 年前不可同日而语。独立博客这样需要坐下来花上个把小时写文章的介质实在很难与 GIF、视频、emoji 抗衡。</p>
<p>作为一个写主题的人，能做的只有为博主带来无障碍的写作环境、为读者带来无障碍的阅读环境。不要去打击博主可能的创作欲，也不要给想获取信息的读者平添难度。</p>
<p>你觉得这简单吗？这一点也不简单。</p>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/247/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/243/" target="_self">初识 Sass | SCSS</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/243/" target="_self">
                <time class="text-uppercase">
                    January 19 2019
                </time>
            </a>
        </div>
        <div class="prism-content"><p>CSS 是很繁琐的。一遍遍地重写类名，一遍遍地重写冗长的属性，真的让人心生厌恶。CSS 作为样式表，不是一种编程语言，你可以用它描述一个网页，但是不能用它编程。</p>
<p>但好在，现在我们已经有了许多相对成熟的解决方案，其中一种就是这篇文章要讲到的 Sass/SCSS。</p>
<h2>这是什么？</h2>
<p>Sass/SCSS 是一种 CSS 的扩展语言，一种预处理器，你可以用它们快速编写样式，然后再编译为浏览器可以解析的标准 CSS 代码。</p>
<p>Sass 提供了诸如变量、嵌套、引入、混合器、继承器等等优秀的特性，使网页设计进行起来更加快速、顺手。但 Sass 使用缩进分块，用起来不甚舒服。</p>
<p>SCSS 是 Sass 的后续升级版本，它完全兼容 CSS 语法，也是就是说，任何合规的 CSS 文件把后缀改为 .scss 后也是合规的 SCSS 文件，支持使用 {} 分块。</p>
<h2>上手</h2>
<blockquote><p>注意，本文语法基于 SCSS，也就是采用 {} 分块。这样更符合我多年的习惯。</p>
</blockquote>
<h3>变量</h3>
<p>这是 SCSS 的一个重要特性。CSS 不能使用变量这个问题已经为人诟病很久了，新标准中终于带来了 <code>var()</code> 语法以提供变量支持，但是兼容性尚较差。在 SCSS 中使用变量很简单：</p>
<div class="highlight"><pre><span></span><span class="c1">// 定义一个变量</span>
<span class="nv">$textColor</span><span class="o">:</span> <span class="mh">#333</span><span class="p">;</span>

<span class="c1">// 运用一个变量</span>
<span class="nt">body</span><span class="p">{</span>
    <span class="nt">color</span><span class="nd">:</span> <span class="err">$</span><span class="nt">textColor</span><span class="o">;</span>
<span class="p">}</span>
</pre></div>
<p>在 {} 块中定义的变量只能在该块内使用，外部定义的变量则可作用于全部范围，这与 C 语言的变量作用域同理。SCSS 变量可以存储的东西很丰富，除了颜色，还可以这样：</p>
<div class="highlight"><pre><span></span><span class="nv">$plainFont</span><span class="o">:</span> <span class="s2">&quot;Myriad Pro&quot;</span><span class="o">,</span> <span class="n">Myriad</span><span class="o">,</span> <span class="s2">&quot;Helvetica Neue&quot;</span><span class="o">,</span> <span class="n">Helvetica</span><span class="o">,</span> <span class="s2">&quot;Liberation Sans&quot;</span><span class="o">,</span> <span class="n">Arial</span><span class="o">,</span> <span class="no">sans-serif</span><span class="o">,</span> <span class="no">sans-serif</span><span class="p">;</span>
</pre></div>
<p>在 SCSS 中，下划线与中划线等价，<code>$link-Color</code> 与 <code>$link_Color</code> 等价。</p>
<h3>嵌套</h3>
<p>这是另一个令人兴奋的特性！想象一下平时我们写的 CSS 代码：</p>
<div class="highlight"><pre><span></span><span class="p">#</span><span class="nn">content</span> <span class="nt">article</span><span class="p">{}</span>
<span class="p">#</span><span class="nn">content</span> <span class="nt">article</span> <span class="nt">p</span><span class="p">{}</span>
<span class="p">#</span><span class="nn">content</span> <span class="nt">article</span> <span class="nt">p</span> <span class="nt">a</span><span class="p">{}</span>
</pre></div>
<p>是不是觉得改变世界的热情已经消失一些了…… SCSS 支持嵌套规则，上面那段代码可以这么书写：</p>
<div class="highlight"><pre><span></span><span class="nn">#content</span><span class="p">{</span>
    <span class="c1">// some attr</span>
    <span class="nt">article</span><span class="p">{</span>
        <span class="c1">// some attr</span>
        <span class="nt">p</span><span class="p">{</span>
            <span class="c1">// some attr</span>
            <span class="nt">a</span><span class="p">{</span>
                <span class="c1">// some attr</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>在大量减少工作量的同时，你的代码可读性也大大提高。另外，SCSS 也支持伪类与伪元素的嵌套，这就涉及父选择器 <code>&amp;</code> 了。例如一段 CSS 代码：</p>
<div class="highlight"><pre><span></span><span class="p">.</span><span class="nc">btn</span><span class="p">{}</span>
<span class="p">.</span><span class="nc">btn</span><span class="p">.</span><span class="nc">large</span><span class="p">{}</span>
<span class="p">.</span><span class="nc">btn</span><span class="p">.</span><span class="nc">large</span><span class="p">.</span><span class="nc">pushed</span><span class="p">{}</span>
<span class="p">.</span><span class="nc">btn</span><span class="p">.</span><span class="nc">large</span><span class="p">.</span><span class="nc">pushed</span><span class="p">:</span><span class="nd">hover</span><span class="p">{}</span>
<span class="p">.</span><span class="nc">btn</span><span class="p">.</span><span class="nc">large</span><span class="p">.</span><span class="nc">pushed</span><span class="p">:</span><span class="nd">hover</span><span class="p">::</span><span class="nd">before</span><span class="p">{}</span>
</pre></div>
<p>在嵌套中使用 <code>&amp;</code> 指代父元素，则在 SCSS 中应该如下书写：</p>
<div class="highlight"><pre><span></span><span class="nc">.btn</span><span class="p">{</span>
    <span class="c1">// some attr</span>
    <span class="k">&amp;</span><span class="nc">.large</span><span class="p">{</span>
        <span class="c1">// some attr</span>
        <span class="k">&amp;</span><span class="nc">.pushed</span><span class="p">{</span>
            <span class="c1">// some attr</span>
            <span class="k">&amp;</span><span class="nd">:hover</span><span class="p">{</span>
                <span class="c1">// some attr</span>
                <span class="k">&amp;</span><span class="nd">::before</span><span class="p">{</span>
                    <span class="c1">// some attr</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>当然，子组合选择器和同层组合选择器：<code>&gt;</code>、<code>+</code> 以及 <code>~</code> 同样支持。以上介绍均属于选择器嵌套，SCSS 嵌套的另一个高级用法是属性嵌套，例如：</p>
<div class="highlight"><pre><span></span><span class="nc">.border</span><span class="p">{</span>
    <span class="nt">border</span><span class="nd">:</span> <span class="p">{</span>
        <span class="nt">style</span><span class="nd">:</span> <span class="nt">solid</span><span class="o">;</span>
        <span class="nt">width</span><span class="nd">:</span> <span class="nt">1px</span><span class="o">;</span>
        <span class="nt">color</span><span class="nd">:</span> <span class="nn">#ccc</span><span class="o">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>这段代码会被编译为：</p>
<div class="highlight"><pre><span></span><span class="p">.</span><span class="nc">border</span><span class="p">{</span>
    <span class="k">border-style</span><span class="p">:</span> <span class="kc">solid</span><span class="p">;</span>
    <span class="k">border-width</span><span class="p">:</span> <span class="mi">1</span><span class="kt">px</span><span class="p">;</span>
    <span class="k">border-color</span><span class="p">:</span> <span class="mh">#ccc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>是不是很酷？注意，用于嵌套的属性前缀后面需要加一个 <code>:</code>。</p>
<h3>引用 SCSS 文件</h3>
<p>你很可能不愿意把整个项目的 CSS 都写在一个文件里，这样实在难以维护。SCSS 支持将代码写在不同文件里然后在别的文件里引用。若当前有目录树如下。</p>

<pre><code>style
    |-- style.scss
    |-- var.scss
    |-- parts
        |-- _sidebar.scss
        |-- _header.scss
        |-- _article.scss</code></pre>
<p>在 style.css 中，你可以使用 <code>@import</code> 命令导入其他代码文件。</p>
<div class="highlight"><pre><span></span><span class="k">@import</span> <span class="s2">&quot;var&quot;</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">&quot;parts/sidebar&quot;</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">&quot;parts/header&quot;</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">&quot;parts/article&quot;</span><span class="p">;</span>
</pre></div>
<p>你或许已经注意到了，导入时文件名无需写全。另外一点需要注意，SCSS 规定以下划线开头的文件不会被单独编译，而会直接被包含到生成的最终 CSS 中。</p>
<h3>混合器</h3>
<p>混合器使你可以重用代码片段，减少工作量。例如一些常用样式的组合，可以直接定义为一个混合器，然后在代码中引用。</p>
<div class="highlight"><pre><span></span><span class="k">@mixin</span><span class="nf"> coverBg</span><span class="p">{</span>
    <span class="nt">background</span><span class="nd">:</span> <span class="p">{</span>
        <span class="nt">size</span><span class="nd">:</span> <span class="nt">cover</span><span class="o">;</span>
        <span class="nt">repeat</span><span class="nd">:</span> <span class="nt">no-repeat</span><span class="o">;</span>
        <span class="nt">position</span><span class="nd">:</span> <span class="nt">center</span><span class="o">;</span>
        <span class="nt">color</span><span class="nd">:</span> <span class="nn">#12121c</span><span class="o">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>然后在某处引用</p>
<div class="highlight"><pre><span></span><span class="nt">div</span><span class="nc">.banner</span><span class="p">{</span>
    <span class="k">@include</span><span class="nd"> coverBg</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>最后的 CSS 是：</p>
<div class="highlight"><pre><span></span><span class="nt">div</span><span class="p">.</span><span class="nc">banner</span><span class="p">{</span>
    <span class="k">background-size</span><span class="p">:</span> <span class="kc">cover</span><span class="p">;</span>
    <span class="k">background-repeat</span><span class="p">:</span> <span class="kc">no-repeat</span><span class="p">;</span>
    <span class="k">background-position</span><span class="p">:</span> <span class="kc">center</span><span class="p">;</span>
    <span class="k">background-color</span><span class="p">:</span> <span class="mh">#12121c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>混合器相当于普通编程语言中宏的概念，你还可以给混合器传参：</p>
<div class="highlight"><pre><span></span><span class="k">@mixin</span><span class="nf"> link-colors</span><span class="p">(</span><span class="nv">$normal</span><span class="o">,</span> <span class="nv">$hover</span><span class="o">,</span> <span class="nv">$visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="nt">color</span><span class="nd">:</span> <span class="err">$</span><span class="nt">normal</span><span class="o">;</span>
    <span class="k">&amp;</span><span class="nd">:hover</span> <span class="p">{</span> <span class="nt">color</span><span class="nd">:</span> <span class="err">$</span><span class="nt">hover</span><span class="o">;</span> <span class="p">}</span>
    <span class="k">&amp;</span><span class="nd">:visited</span> <span class="p">{</span> <span class="nt">color</span><span class="nd">:</span> <span class="err">$</span><span class="nt">visited</span><span class="o">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>使用时只需要这样：</p>
<div class="highlight"><pre><span></span><span class="nt">a</span> <span class="p">{</span>
    <span class="k">@include</span><span class="nd"> link-colors</span><span class="p">(</span><span class="ni">blue</span><span class="o">,</span> <span class="ni">red</span><span class="o">,</span> <span class="ni">green</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>其结果是：</p>
<div class="highlight"><pre><span></span><span class="nt">a</span> <span class="p">{</span> <span class="k">color</span><span class="p">:</span> <span class="kc">blue</span><span class="p">;</span> <span class="p">}</span>
<span class="nt">a</span><span class="p">:</span><span class="nd">hover</span> <span class="p">{</span> <span class="k">color</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span> <span class="p">}</span>
<span class="nt">a</span><span class="p">:</span><span class="nd">visited</span> <span class="p">{</span> <span class="k">color</span><span class="p">:</span> <span class="kc">green</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
<h3>继承</h3>
<p>继承同样可以减少重复工作，它使一个选择器可以直接继承另一个选择器的所有样式。例如：</p>
<div class="highlight"><pre><span></span><span class="nc">.error</span> <span class="p">{</span>
   <span class="nt">border</span><span class="nd">:</span> <span class="nt">1px</span> <span class="nt">solid</span> <span class="nt">red</span><span class="o">;</span>
   <span class="nt">background-color</span><span class="nd">:</span> <span class="nn">#fdd</span><span class="o">;</span>
<span class="p">}</span>
<span class="nc">.seriousError</span> <span class="p">{</span>
   <span class="k">@extend</span> <span class="nc">.error</span><span class="o">;</span>
   <span class="nt">border-width</span><span class="nd">:</span> <span class="nt">3px</span><span class="o">;</span>
<span class="p">}</span>
</pre></div>
<p>注意，<code>.seriousError</code> 不仅继承了 <code>.error</code> 的样式，任何与 <code>.error</code> 相关的组合选择器样式也会被继承。</p>
<h2>如何使用 SCSS 开发</h2>
<h3>安装</h3>
<p>以上是 SCSS 最常用的一些特性，更多特性没必要一一列举，因为反正也记不完，用到再说。既然 SCSS 这么棒，当务之急是在自己的项目中用上它。</p>
<p>首先需要安装 Ruby，如果你使用 Mac，则自带 Ruby；如果是 Windows，<a href="http://rubyinstaller.org/downloads">下载 Ruby</a>后安装。然后修改一下 gem 镜像。</p>
<div class="highlight"><pre><span></span>gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/
gem sources -l
<span class="c1"># 确保只有 gems.ruby-china.com</span>
</pre></div>
<p>然后安装 Sass 与 Compass：</p>
<div class="highlight"><pre><span></span>gem install Sass
gem install compass
</pre></div>
<p>你可能需要 <code>sudo</code> 权限。</p>
<h3>命令行使用</h3>
<div class="highlight"><pre><span></span>//单文件转换命令
Sass input.scss output.css

//单文件监听命令
Sass --watch input.scss:output.css

//如果你有很多的Sass文件的目录，你也可以告诉Sass监听整个目录：
Sass --watch app/Sass:public/stylesheets
</pre></div>
<h3>VS Code</h3>
<p>也可以配合 VS Code 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.live-Sass">Live Sass Compiler</a> 来使用，好处是自带了 <a href="https://github.com/postcss/autoprefixer">autoprefixer</a>，而且可以实现每次保存后立即重新编译。</p>
<p>插件具体配置见：<a href="https://github.com/ritwickdey/vscode-live-Sass-compiler/blob/master/docs/settings.md">setting docs</a>。</p>
<h2>总结与其它</h2>
<p>会写这篇文章是因为最近考完试了想要学点新东西，正好有写个新主题的念头，随即动手。于是，新主题的大部分样式都是使用 SCSS 写的。</p>
<p>另外，新主题 VOID 已经发布，详见 <a href="https://github.com/AlanDecode/Typecho-Theme-VOID">AlanDecode/Typecho-Theme-VOID</a>。</p>
<div class="notice">本文参考了 <a href="https://www.Sass.hk/guide/">Sass 中文网</a></div></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/243/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/231/" target="_self">2018 下半年博客流量统计</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/231/" target="_self">
                <time class="text-uppercase">
                    December 31 2018
                </time>
            </a>
        </div>
        <div class="prism-content"><p>博客从建站起就接入了百度统计，但是后来几经搬家，过程中切换了域名，到现在数据却不全。今天兴起一看，最早的数据是今年 7 月末，年报写不了，寻思写个半年报水一下吧。</p>
<p>那么，以下是今年 7 月 31 日至 12 月 31 日的统计数据~</p>
<p><figure class="pswp-item" style="flex: 100.23980815347721" data-width="1672" data-height="834"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/b0c45dffcccc52cc509c140920975a5f.png" alt="Snipaste_2018-12-31_13-09-08.png" /><figcaption>Snipaste_2018-12-31_13-09-08.png</figcaption></figure></p>
<p><strong>啊，真少啊</strong>。</p>
<p>为什么直接访问的会这么多呢？8W+ PV，1W+ 的 UV，足以说明问题：大多数的流量都是自己贡献给自己的。</p>
<p>8 月 27 日突然反常，外链来源超过了直接访问，没想出原因来……可能那天换了模板啥的。</p>
<p>跳出率 47%，这个数是高还是低呢？感觉应该没人会在网站上逗留吧？但是 8 分钟的平均访问时间，如果只看一个页面又显得有些长了。看来还是有一定的朋友在本站深♂入探索过。</p>
<p><figure class="pswp-item" style="flex: 99.94011976047904" data-width="1669" data-height="835"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/694fdb1dacd629336f232cc4cefb5c31.png" alt="Snipaste_2018-12-31_13-18-07.png" /><figcaption>Snipaste_2018-12-31_13-18-07.png</figcaption></figure></p>
<p>从来源来看，typecho.me 带来了不少流量啊，这是由于我把主题投稿到了那里的原因。然后就是我自己的引导页，这个我有点怀疑的说，因为平时感觉没啥人访问引导页。接下来是 GitHub 和 handsome 的文档站。handsome 真厉害，一个文档站带来的流量就有这么多了。之后是几个小伙伴的站点，最后一个是少数派，因为我发在少数派上的文章都留了博客的对应网址，所以也带来了一定的流量。</p>
<p>搜索引擎来看，竟然是百度比较多，这个有点吃惊的。本站直到今年 9 月百度索引量都是个位数而已，但 11 月以来索引量有了长足进步，一度突破 100。然而 Google 一直都超过 300 :@(亲亲)。收录速度也是 Google 远胜过百度。我记得我把博客域名短暂地换到 www.imalan.cn 时，Google 几乎第二天就更新链接了，百度？除了掉收录之外没别的。</p>
<p>再来看看访客分布吧。</p>
<p><figure class="pswp-item" style="flex: 99.76047904191617" data-width="1666" data-height="835"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/b6e1d372b5418c86136b2734c01a3028.png" alt="Snipaste_2018-12-31_13-30-30.png" /><figcaption>Snipaste_2018-12-31_13-30-30.png</figcaption></figure></p>
<p>看看那一枝独秀的北京，太羞耻了哈哈。去除北京，来源最多的是广东，还是蛮合理的。话说这半年，一个宁夏的访客都没有，神奇。</p>
<p>按国家来看：</p>
<p><figure class="pswp-item" style="flex: 99.9400479616307" data-width="1667" data-height="834"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/c30db899be085735ec7ac5c2679c907d.png" alt="Snipaste_2018-12-31_13-33-12.png" /><figcaption>Snipaste_2018-12-31_13-33-12.png</figcaption></figure></p>
<p>除了非洲，几大洲都有访客。大概因为没有代理路线会去非洲吧。</p>
<div class="photos">
<figure class="pswp-item" style="flex: 100.23952095808383" data-width="1674" data-height="835"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/f7e30beb1262bf8671a4ac73da80f155.png" alt="浏览器分布" /><figcaption>浏览器分布</figcaption></figure>
<figure class="pswp-item" style="flex: 100.18028846153847" data-width="1667" data-height="832"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/0ac3c4eb1a456faf288556b436862929.png" alt="计算机端" /><figcaption>计算机端</figcaption></figure>
<figure class="pswp-item" style="flex: 100.0" data-width="1666" data-height="833"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/e791003bb4caab3ad6731088701f9d05.png" alt="移动端" /><figcaption>移动端</figcaption></figure></div><p>出人意料，竟然还是计算机端访问比较多。Chrome 占压倒性优势，移动端则是 Safari（毕竟我用 Safari）。这更坚定了我不为 IE 做任何额外兼容工作的决心（使用 IE 的各位对不住了）。</p>
<p><figure class="pswp-item" style="flex: 99.82014388489209" data-width="1665" data-height="834"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/38dc0e3dc4cc525045cf932f1ec74f41.png" alt="Snipaste_2018-12-31_13-39-11.png" /><figcaption>Snipaste_2018-12-31_13-39-11.png</figcaption></figure></p>
<p>1920×1080 的屏幕仍然是主导地位，2K 屏幕没有想象的多。令人欣慰的是 1366×768 这种屏幕已经很少了。1356×864 和 375×667 是两个常见的移动端屏幕分辨率，也值得注意。</p>
<p><figure class="pswp-item" style="flex: 99.82078853046595" data-width="1671" data-height="837"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/b6b0ecf2c6977e731ea50159ef4a496c.png" alt="Snipaste_2018-12-31_13-45-20.png" /><figcaption>Snipaste_2018-12-31_13-45-20.png</figcaption></figure></p>
<p>访客 94% 都是男性，看来本站很受大♂哥♂哥们的青睐呢。高中及以下学历的大佬好多，想想我高中的时候在干嘛？玩泥巴。</p>
<p><figure class="pswp-item" style="flex: 100.18072289156626" data-width="1663" data-height="830"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/89e3e4a6bebef44585fcf1164c209aab.png" alt="Snipaste_2018-12-31_13-48-06.png" /><figcaption>Snipaste_2018-12-31_13-48-06.png</figcaption></figure></p>
<p>哇，多达三分之二的访客是新访客呢。（这是不是说明大家都不想再来第二次:@(深思)）</p>
<p>总结一下吧，这半年还是挺稳的。</p>
<p>发布主题、插件，再投稿到别的大流量站点会带来不少访客，但是大多数是看一眼就走的；发布技术性文章不会带来太多流量，但是通过搜索引擎可以帮助到别人，这是意义所在。发布日常内容嘛，大概就是常互访的伙伴们会看，这类内容搜索引擎也没那么喜欢。</p>
<p>我可能要重新搞一个专门发技术性文章的站点。把 SEO 搞好一点，然后以阅读体验为主，没那么花里胡哨。</p>
<p>（咕咕咕）</p>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/231/#prism__comment" target="_self"><i class="fa fa-comment"></i>评论</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next">
                <a class="no-link" href="/page/3/" target="_self"><i class="fa fa-chevron-left" aria-hidden="true"></i>更新</a>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/5/" target="_self">更旧<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/AlanDecode" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/AlanDecode" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/5245109677/" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">三無計劃</a>：三是虚指。至于是哪三无，我唔知。
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://wiki.imalan.cn" rel="noopener noreferrer nofollow">無知識</a>：熊猫小A的Wiki站点。隶属于「三无计划」。
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://lab.imalan.cn" rel="noopener noreferrer nofollow">無項目</a>：熊猫小A的实验室。隶属于「三无计划」。
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://t.me/triple_null" rel="noopener noreferrer nofollow">無消息</a>：熊猫小A的广播。隶属于「三无计划」。
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">无文字 | 三无计划</span>
                            <span>Copyright © 2020 熊猫小A</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
<a no-style href="http://beian.miit.gov.cn" target="_blank">京ICP备18000133号-1</a> | 
<a no-style href="https://www.upyun.com" target="_blank">又拍云</a>

                    </div>
                </section>
                <script>
                    var site_build_date = "2017-06-29T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/prism-a1bd79b1a4.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
<script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e4f3a7c02ac2aabc41a1cfa95f61a026";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
</script>
<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<script>
if(window.location.hash){
    var checkExist = setInterval(function() {
       if ($(window.location.hash).length) {
          $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
          clearInterval(checkExist);
       }
    }, 100);
}
</script>
<script>
if(window.navigator && navigator.serviceWorker) {
  caches.keys().then(function(cacheNames) {
    cacheNames.forEach(function(cacheName) {
      caches.delete(cacheName);
    });
  }).then(function(){
    console.log('Cache cleaned.');
  });
  navigator.serviceWorker.getRegistrations()
  .then(function(registrations) {
    for(let registration of registrations) {
      registration.unregister();
    }
  }).then(function(){
    console.log('Service Worker stopped.');
  });
}
</script>

</body>

</html>